

module game(input clk, clk2, rst, input logic [3:0] pushbutts, output derrota, victoria, output int arrayout [15:0]);


logic [2:0] state, next_state;
logic revision;
logic direcciones;
logic limite;
logic  [3:0]entradas;
int array[15:0];
int arraywork[15:0];
int irand;
int jrand;
logic randasign;


logic clk1; 
logic check; 



game_manager U0(.clk1(clk1), .entradas(entradas), .array(array), .arraywork(arraywork));

//actual state logic
always_ff @ (posedge clk or posedge rst) begin
	if (rst) state = 3'b000;
	else
		state = next_state;
	arrayout = array;

end

always @ (pushbutts) begin
	if (pushbutts == 4'b0000) begin
		entradas = pushbutts; //El orden es de bits (más a menos significativo) es primero arriba, segundo abajo, tercero derecha, cuarto izquierda
	end
	
end
		

	
		
//next state logic
always @(*) begin
		
		
		case (state)
		
			3'b000:begin
				for (int i=0; i<4; i = i+1) begin
					for (int j=0; j<4; j = j+1) begin
						array[4*i+j] = 0;
	
					end

				end

				next_state = 3'b001;
			end
			3'b001: begin
				revision = 1'b1; //revisar si hay condición de juego
				if(revision) begin 
					randasign = 0;
					for (int i =0; i<4; i=i+1) begin
						for (int j=0; j<4; j=j+1) begin
							
							if ((array[4*i+j] == 0) && (randasign == 0)) begin
								randasign = 1;
								array[4*i+j] = 1;
							end
							
						end
					
					end
						
						

					next_state = 3'b010; 
				end	
				
				else next_state = 3'b110; 
			end
			
			3'b010: begin 
				if(entradas != 4'b0000) next_state = 3'b011; //Revisa si hay entradas
				else next_state = 3'b010;
			end
			
			
			3'b011: begin 
				//Evalua la direccion en comparacion a los cuadrados
				clk1 = 1;
				if(check) next_state = 3'b100;
				else next_state = 3'b001;
				
			end
			
			3'b100: begin 
				clk1 = 0;
				array = arraywork;
				limite = 1'b0; //Revisa por cada cuadrado si alguno supera el limite
				if(limite) next_state = 3'b101;
				else next_state = 3'b001;
			end
			
			
			3'b101: begin 
				next_state = 3'b101; //posible reinicio
			end
			
			
			3'b110: begin 
				next_state = 3'b110; //posible reinicio
			end
			
			
			default: next_state = 3'b000;
		
		endcase

end
//output logic
assign derrota = (state == 3'b101);
assign victoria = (state == 3'b11);		

endmodule


module game_manager(input logic clk1, input logic[3:0] entradas, input int array[15:0], output int arraywork[15:0]);

	logic check;
	int restante;
	logic continue_check;
	int current_value;
	int last_i;
	int last_j;
	int var_new;
	
	

	
	always @ (posedge clk1) begin
	
		check = 0;
		
				
		for (int i=0; i<4; i=i+1) begin 

			for (int j=0; j<4; j=j+1) begin
				
				continue_check = 1;
				last_i = i;
				last_j = j;
				
				if (array[4*i+j] != 0) begin
				
					//Revisa arriba
					if (entradas == 4'b1000) begin
						restante = i-1;
						if (restante > 0) begin
							for (int x=3; x>-1; x=x-1) begin
								if (x <= restante) begin
									if ((array[4*i+j] == array[4*x+j]) && continue_check) begin
										check = 1;
										arraywork[4*i+j] = 0;
										arraywork[4*x+j] = 2*array[4*x+j];
										continue_check = 0;
									
									end 
									else if (continue_check && (array[4*x+j] != array[4*i+j]) && (array[4*x+j] != 0)) begin
										continue_check = 0;
										arraywork[4*i+j] = array[4*i+j];
									
									end else if (continue_check && (arraywork[4*x+j] == 0)) begin
										last_i = x;
										last_j = j;
										arraywork[4*i+j] = array[4*i+j];
										
									end 
								end
							end
						end
					
					end
					//Revisa abajo
					if (entradas == 4'b0100) begin
						restante = i+1;
						if (restante < 3) begin
							for (int x=0; x<4; x=x+1) begin
								if (x >= restante) begin
									if ((array[4*i+j] == array[4*x+j]) && continue_check) begin
										check = 1;
										arraywork[4*i+j] = 0;
										arraywork[4*x+j] = 2*array[4*x+j];
										continue_check = 0;
									
									end else if (continue_check && (array[4*x+j] != array[4*i+j]) && (array[4*x+j] != 0)) begin
										continue_check = 0;
									
									end else if (continue_check && (array[4*x+j] == 0)) begin
										last_i = x;
										last_j = j;
										
									end
								end
							end
						end
					
					end
					//Revisa derecha
					if (entradas == 4'b0010) begin
						restante = j-1;
						if (restante >0) begin
							for (int x=3; x>-1; x=x-1) begin
								if (x <= restante) begin
									if ((array[4*i+j] == array[4*i+x]) && continue_check) begin
										check = 1;
										arraywork[4*i+j] = 0;
										arraywork[4*i+x] = 2*array[4*i+x];
										continue_check = 0;
									
									end else if (continue_check && (array[4*i+x] != array[4*i+j]) && (array[4*i+x] != 0)) begin
										continue_check = 0;
									
									end else if (continue_check && (array[4*i+x] == 0)) begin
										last_i = i;
										last_j = x;
										
									end
								end	
							end
						end
					
					end
					//Revisa izquierda
					if (entradas == 4'b0001) begin
						restante = j+1;
						if (restante < 15) begin
							for (int x=0; x<4; x=x+1) begin
								if (x >= restante) begin
									if (array[4*i+j] == array[4*i+x]) begin
										check = 1;
										arraywork[4*i+j] = 0;
										arraywork[4*i+x] = 2*array[4*i+x];
										continue_check = 0;
									
									end else if (continue_check && (array[4*i+x] != array[4*i+j]) && (array[4*i+x] != 0)) begin
										continue_check = 0;
								
									end else if (continue_check && (array[4*i+x] == 0)) begin
										last_i = i;
										last_j = x;
										
									end
								end
								
							end
							
						end
					
					end
					
					if (check == 0) begin 
						var_new = array[4*i+j];
						arraywork[4*i+j] = 0;
						arraywork[4*last_i+last_j] = var_new;
						
					end
				
				end else begin
					arraywork[4*i+j] = 0;
				
				end
				
			end
		
		end
	end


		
endmodule


